var documenterSearchIndex = {"docs":
[{"location":"apiref/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"apiref/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"apiref/#H2Trees.AbstractTranslationTrait","page":"API Reference","title":"H2Trees.AbstractTranslationTrait","text":"abstract type AbstractTranslationTrait\n\nAbstract type for translation traits.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#H2Trees.AggregateMode","page":"API Reference","title":"H2Trees.AggregateMode","text":"AggregateMode <: FarMulMode\n\nThis mode uses AggregatePlan and DisaggregateTranslatePlan to perform the farmultiplication.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#H2Trees.AggregateTranslateMode","page":"API Reference","title":"H2Trees.AggregateTranslateMode","text":"AggregateTranslateMode <: FarMulMode\n\nThis mode uses AggregateTranslatePlan and DisaggregatePlan to perform the farmultiplication.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#H2Trees.AllTranslations","page":"API Reference","title":"H2Trees.AllTranslations","text":"struct AllTranslations <: AbstractTranslationTrait\n\nRepresents the translation trait where all translations that occur are unique and are stored individually.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#H2Trees.BlockTree","page":"API Reference","title":"H2Trees.BlockTree","text":"BlockTree\n\n\n\n\n\n","category":"type"},{"location":"apiref/#H2Trees.BoundingBallTree","page":"API Reference","title":"H2Trees.BoundingBallTree","text":"BoundingBallTree\n\n\n\n\n\n","category":"type"},{"location":"apiref/#H2Trees.ChildIterator","page":"API Reference","title":"H2Trees.ChildIterator","text":"ChildIterator{T,N<:Integer}\n\nAn iterator over the children of a node in a tree.\n\nFields\n\ntree::T: The tree.\nnode::N: The node whose children are being iterated over.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#H2Trees.DepthFirstIterator","page":"API Reference","title":"H2Trees.DepthFirstIterator","text":"DepthFirstIterator{T,N<:Integer}\n\nTraverses the tree in a depth first manner. If no node is specified the tree is traversed from the root node.\n\nFields\n\ntree::T: The tree.\nnode::Int: The node from which the tree is traversed.\n\nMethods\n\nDepthFirstIterator(tree, node)\n\nCreates a new DepthFirstIterator instance, traversing the tree from the specified node.\n\nDepthFirstIterator(tree)\n\nCreates a new DepthFirstIterator instance, traversing the tree from the root node.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#H2Trees.DirectionInvariance","page":"API Reference","title":"H2Trees.DirectionInvariance","text":"struct DirectionInvariance <: AbstractTranslationTrait\n\nRepresents the translation trait where the direction of translation is invariant, i.e., translations in different directions are identical. Therefore, only one version of the translation is stored.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#H2Trees.DirectionInvariancePerLevel","page":"API Reference","title":"H2Trees.DirectionInvariancePerLevel","text":"struct DirectionInvariancePerLevel <: AbstractTranslationTrait\n\nRepresents the translation trait where translations on the same level with the same length and direction are identical. Therefore, only one version of the translation is stored.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#H2Trees.ParentUpwardsIterator","page":"API Reference","title":"H2Trees.ParentUpwardsIterator","text":"ParentUpwardsIterator{T,N<:Int}\n\nParentUpwardsIterator is an iterator that iterates over all parent nodes of a given node in a tree until the root is reached. The last node is the node 0.\n\nFields\n\ntree::T: The tree.\nnode::Int: The node over which parents is iterated.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#H2Trees.QuadPointsTree","page":"API Reference","title":"H2Trees.QuadPointsTree","text":"QuadPointsTree\n\n\n\n\n\n","category":"type"},{"location":"apiref/#H2Trees.SimpleHybridTree","page":"API Reference","title":"H2Trees.SimpleHybridTree","text":"SimpleHybridTree\n\n\n\n\n\n","category":"type"},{"location":"apiref/#H2Trees.TwoNTree","page":"API Reference","title":"H2Trees.TwoNTree","text":"TwoNTree\n\n\n\n\n\n","category":"type"},{"location":"apiref/#H2Trees.FarNodeIterator-Tuple{Any, Int64}","page":"API Reference","title":"H2Trees.FarNodeIterator","text":"See NearNodeIterator.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.LevelIterator-Tuple{Any, Int64}","page":"API Reference","title":"H2Trees.LevelIterator","text":"LevelIterator(tree, level::Int)\n\nReturn an iterator over the nodes at the specified level in the tree.\n\nArguments\n\ntree: The tree object.\nlevel: The level at which to iterate.\n\nReturns\n\nAn iterator over the nodes at the specified level.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.NearNodeIterator-Tuple{Any, Any, Int64}","page":"API Reference","title":"H2Trees.NearNodeIterator","text":"NearNodeIterator(testtree, trialtree, trialnode::Int; isnear=isnear)\n\nReturns an iterator over the nodes in the testtree that are at the same level as the specified node in the trialtree and are near to node. Two nodes are near if the function isnear(testtree, trialtree, testnode, trialnode) evaluates to true.\n\nArguments\n\ntesttree: The tree to search for near nodes.\ntrialtree: The tree that contains the node to find near nodes for.\ntrialnode::Int: The node in the trialtree from which to start the search.\nisnear: A function that returns true if two nodes are near each other. Defaults to isnear.\n\nReturns\n\nAn iterator over the nodes in the testtree that are at the same level as the specified node in the trialtree and are near to node.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.NearNodeIterator-Tuple{Any, Int64}","page":"API Reference","title":"H2Trees.NearNodeIterator","text":"NearNodeIterator(tree, node::Int; isnear=isnear)\n\nReturns an iterator over the nodes in the tree that are at the same level as the specified node and are near to node. Two nodes are near if the function isnear(tree, nodea, nodeb) evaluates to true.\n\nArguments\n\ntree: The tree to search for near nodes.\nnode::Int: The node from which to start the search.\nisnear: A function that returns true if two nodes are near each other. Defaults to isnear.\n\nReturns\n\nAn iterator over the nodes in the tree that are at the same level as the specified node and are near to node.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.NodeFilterIterator-Tuple{Any, Any, Int64, Any}","page":"API Reference","title":"H2Trees.NodeFilterIterator","text":"NodeFilterIterator(testtree, trialtree, trialnode::Int, filter)\n\nReturns an iterator over nodes at the same level as trialnode in trialtree, for which the function filter(testtree, trialtree, testnode, trialnode) return true.\n\nIn the case of a tree with the trait isBlockTree, it is assumed that trialnode is belonging to the trialtree.\n\nArguments\n\ntesttree: The tree to iterate over\ntrialtree: The tree to which the trialnode belongs to\ntrialnode::Int: The node to start from\nfilter: A function that takes a test tree, a trial tree, a test node, and a trial node and returns a boolean\n\nReturns\n\nAn iterator over nodes at the same level as trialnode that pass the filter\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.NodeFilterIterator-Tuple{Any, Int64, Any}","page":"API Reference","title":"H2Trees.NodeFilterIterator","text":"NodeFilterIterator(tree, node::Int, filter)\n\nReturns an iterator that returns nodes at the same level as node, for which the function filter(tree, nodea, nodeb) or the function filter(testtree, trialtree, testnode, trialnode) return true. In the case of a tree with the trait isBlockTree it is assumed that node is belonging to the trialtree.\n\nArguments\n\ntree: The tree to iterate over\nnode::Int: The node to start from\nfilter: A function that takes a tree and two nodes and returns a boolean\n\nReturns\n\nAn iterator over nodes at the same level as node that pass the filter\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.SameLevelIterator-Tuple{Any, Int64}","page":"API Reference","title":"H2Trees.SameLevelIterator","text":"SameLevelIterator(tree, node::Int)\n\nReturns an iterator over the nodes at the same level as node in the tree.\n\nArguments\n\ntree: The tree structure.\nnode: The node for which to find the same level nodes.\n\nReturns\n\nAn iterator over the nodes at the same level as node.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.TranslatingNodesIterator","page":"API Reference","title":"H2Trees.TranslatingNodesIterator","text":"TranslatingNodesIterator\n\nThis is a wrapper for the `WellSeparatedIterator`.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#H2Trees.WellSeparatedIterator-Tuple{Any, Any, Int64}","page":"API Reference","title":"H2Trees.WellSeparatedIterator","text":"WellSeparatedIterator(testtree, trialtree, trialnode::Int; iswellseparated=iswellseparated)\n\nConstructs an iterator to identify which translations should occur and which should not. This determination is based on the concept of well-separated nodes. Two nodes are considered well-separated if their parents are near each other and the nodes themselves are far apart. This assumes that child clusters are completely inside their parent clusters.\n\nArguments\n\ntesttree: the test tree\ntrialtree: the trial tree\ntrialnode: the node in the trial tree for which the translations happen\niswellseparated: a function that returns true if two nodes are well-separated and false otherwise\n\nReturns\n\nAn iterator that yields the nodes in the testtree that are well-separated from the specified trialnode in the trialtree.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.WellSeparatedIterator-Tuple{Any, Int64}","page":"API Reference","title":"H2Trees.WellSeparatedIterator","text":"WellSeparatedIterator(tree, node::Int; iswellseparated=iswellseparated)\n\nConstructs an iterator to identify which translations should occur and which should not. This determination is based on the concept of well-separated nodes. Two nodes are considered well-separated if their parents are near each other and the nodes themselves are far apart. This assumes that child clusters are completely inside their parent clusters.\n\nArguments\n\ntree: the tree in which the translations occur\nnode: the node for which the translations happen\niswellseparated: a function that returns true if two nodes are well-separated and false otherwise\n\nReturns\n\nAn iterator that yields the nodes that are well-separated from the specified node in the tree.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.WellSeparatedIterator-Tuple{}","page":"API Reference","title":"H2Trees.WellSeparatedIterator","text":"WellSeparatedIterator(; isnear=nothing, iswellseparated=nothing)\n\nConstructs a functor that returns a WellSeparatedIterator if provided a tree. Two nodes are considered well-separated if their parents are near each other and the nodes themselves are far apart. This assumes that child clusters are completely inside their parent clusters.\n\nArguments\n\nisnear: a function that takes a tree as input and returns another function. This returned function is then used to evaluate the isnear criterion.\niswellseparated: a function that takes a tree as input and returns another function. This returned function is then used to evaluate the iswellseparated criterion.\n\nReturns\n\nA WellSeparatedIteratorFunctor that returns a WellSeparatedIterator if provided with a tree.\n\nThrows\n\nerror: if both isnear and iswellseparated are provided, or if neither is provided.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.boundingbox-Union{Tuple{AbstractArray{StaticArraysCore.SVector{D, T}, 1}}, Tuple{T}, Tuple{D}} where {D, T}","page":"API Reference","title":"H2Trees.boundingbox","text":"boundingbox(points::Vector{SVector{D, T}})\n\nReturns halfsize and center of bounding box of points. The halfsize is the half of the length of the edge of the bounding box.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.cornerpoints-Union{Tuple{T}, Tuple{D}, Tuple{N}, Tuple{TwoNTree{N, D, T}, Int64, Any}} where {N, D, T}","page":"API Reference","title":"H2Trees.cornerpoints","text":"cornerpoints(tree::TwoNTree{N,D,T}, node::Int, i)\n\nReturn the corner point of a given node in an N-dimensional TwoNTree.\n\nArguments\n\ntree::TwoNTree{N,D,T}: The tree.\nnode::Int: The index of the node.\ni: The corner point index (1 til 2^N).\n\nReturns\n\nThe corner point coordinates as a SVector.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.findleafnode-Tuple{Any, Int64}","page":"API Reference","title":"H2Trees.findleafnode","text":"findleafnode(tree, value::Int)\n\nFind the leaf node in the given tree that contains the specified value.\n\nArguments\n\ntree: The tree to search in.\nvalue: The value to search for.\n\nReturns\n\nThe leaf node that contains the value, or 0 if not found.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.isnear-Tuple{}","page":"API Reference","title":"H2Trees.isnear","text":"isnear\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.iswellseparated-Tuple{}","page":"API Reference","title":"H2Trees.iswellseparated","text":"iswellseparated\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.leaves","page":"API Reference","title":"H2Trees.leaves","text":"leaves(tree, node::Int)\n\nReturns an iterator over the leaf nodes in the tree, starting from the specified node. If no node is specified the tree is traversed from the root node.\n\nArguments\n\ntree: The tree to search for leaf nodes.\nnode::Int: The node from which to start the search.\n\nReturns\n\nAn iterator over the leaf nodes in the tree.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#H2Trees.leveltolevelid-Tuple{Any, Int64}","page":"API Reference","title":"H2Trees.leveltolevelid","text":"leveltolevelid(tree, level::Int)\n\nConverts a level in the tree to its corresponding level ID. This is relevant since the first level might not be level 1.\n\nArguments\n\ntree: The tree object.\nlevel: The level to convert.\n\nReturns\n\nThe level ID corresponding to the given level.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.minimumlevel-Tuple{Any}","page":"API Reference","title":"H2Trees.minimumlevel","text":"minimumlevel(tree)\n\nGet the minimum level of a tree, which is the level of the root node. This is not necessarily the level 1.\n\nArguments\n\ntree: The tree.\n\nReturns\n\nThe minimum level of the tree.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.parentcenterminuschildcenter-Union{Tuple{T}, Tuple{D}, Tuple{N}, Tuple{TwoNTree{N, D, T}, Int64}} where {N, D, T}","page":"API Reference","title":"H2Trees.parentcenterminuschildcenter","text":"parentcenterminuschildcenter(tree::TwoNTree{N,D,T}, child::Int) where {D,T}\n\nCalculate the difference r_p-r_c between the center of the parent r_p and the center of the child node r_c.\n\nArguments\n\ntree::TwoNTree{N,D,T}\nchild::Int: The index of the child node.\n\nReturns\n\nSVector{N,T}: The difference between the center of the parent node and the center of the child node.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.translations-Tuple{Any, H2Trees.AbstractPlan, Any}","page":"API Reference","title":"H2Trees.translations","text":"function translations(tree, translatingplan::AbstractPlan, translationtrait)\n\nCompute the translations of the tree based on the given translating plan and translation trait.\n\nArguments\n\ntree: The tree\ntranslatingplan::AbstractPlan: The plan describing the translations in the tree\ntranslationtrait: The trait describing the translations\n\nReturns\n\nA tuple containing two vectors:\n\nThe first vector contains NamedTuples with fields receivingnode, translatingnode, and translationID. The translationID is the id of the translation in the translation directions.\nThe second vector contains the translation directions.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.values-Tuple{Any, Int64}","page":"API Reference","title":"H2Trees.values","text":"values(tree, node::Int)\n\nReturns the values stored in the given node of the tree. If the node is a leaf node, it returns the values directly. Otherwise, it recursively collects the values from all the leaf nodes in the subtree rooted at the given node.\n\nArguments\n\ntree: The H2 tree.\nnode::Int: The index of the node.\n\nReturns\n\nAn array of values stored in the given node or its subtree.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.TwoNTree-Tuple{BEAST.Space, Any}","page":"API Reference","title":"H2Trees.TwoNTree","text":"TwoNTree(space::BEAST.Space, minhalfsize; kwargs...)\n\nConstruct a TwoNTree from a given BEAST.Space.\n\nArguments\n\nspace::BEAST.Space: The input space.\nminhalfsize: The minimum half-size of the tree.\nkwargs...: Additional keyword arguments.\n\nReturns\n\nA TwoNTree.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.TwoNTree-Tuple{BEAST.Space, BEAST.Space, Any}","page":"API Reference","title":"H2Trees.TwoNTree","text":"TwoNTree(testspace::BEAST.Space, trialspace::BEAST.Space, minhalfsize; kwargs...)\n\nConstruct a block tree with two TwoNTrees from two given spaces: a test space and a trial space.\n\nArguments\n\ntestspace::BEAST.Space: The test space.\ntrialspace::BEAST.Space: The trial space.\nminhalfsize: The minimum half-size of the tree.\nkwargs...: Additional keyword arguments.\n\nReturns\n\nA TwoNTree.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.traceball-Tuple{H2Trees.H2ClusterTree, Int64}","page":"API Reference","title":"H2Trees.traceball","text":"traceball(center::H2ClusterTree, radius; n=30, kwargs...) where\n\nReturns a trace, which can be used to plot a bounding ball of a BoundingBallTree in PlotlyJS. All 'kwargs' are passed to PlotlyJS.scatter or PlotlyJS.surface, respectively.\n\nArguments:\n\ntree::H2ClusterTree: Tree\nnode: Cluster to plot.\nkwargs: keyword arguments passed to PlotlyJS\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.traceball-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, Any}} where T","page":"API Reference","title":"H2Trees.traceball","text":"traceball(center::SVector{D,T}, radius; n=30, kwargs...) where {D,T}\n\nReturns a trace, which can be used to plot a bounding ball in PlotlyJS. All 'kwargs' are passed to PlotlyJS.scatter or PlotlyJS.surface, respectively.\n\nArguments:\n\ncenter: Center of the bounding ball.\nradius: Radius of bounding ball.\nkwargs: keyword arguments passed to PlotlyJS\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.tracecube-Tuple{H2Trees.H2ClusterTree, Int64}","page":"API Reference","title":"H2Trees.tracecube","text":"tracecube(tree::H2ClusterTree, node::Int; kwargs...)\n\nReturns a trace, which can be used to plot a cluster of a TwoNTree in PlotlyJS. All 'kwargs' are passed to PlotlyJS.scatter or PlotlyJS.scatter3d, respectively.\n\nArguments:\n\ntree::H2ClusterTree: tree\nnode::Int: Cluster to plot\nkwargs: keyword arguments passed to PlotlyJS\n\n\n\n\n\n","category":"method"},{"location":"apiref/#H2Trees.tracecube-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{2, T}, T}} where T","page":"API Reference","title":"H2Trees.tracecube","text":"tracecube(center::SVector{D, T}, halfsize; kwargs...)\n\nReturns a trace, which can be used to plot a bounding box in PlotlyJS. All 'kwargs' are passed to PlotlyJS.scatter or PlotlyJS.scatter3d, respectively.\n\nArguments:\n\ncenter: Center of the bounding box.\nhalfsize: Halfsize of the bounding box, which is half of the length of the edge of the bounding box.\nkwargs: keyword arguments passed to PlotlyJS\n\n\n\n\n\n","category":"method"},{"location":"plans/aggregateplan/#Aggregate-Plan","page":"Aggregate Plan","title":"Aggregate Plan","text":"","category":"section"},{"location":"ext/h2plotlyjstrees/#PlotlyJS","page":"PlotlyJS","title":"PlotlyJS","text":"","category":"section"},{"location":"ext/h2plotlyjstrees/","page":"PlotlyJS","title":"PlotlyJS","text":"PlotlyJS.jl can be used to visualize the clusters of a tree.","category":"page"},{"location":"ext/h2plotlyjstrees/#Visualizing-a-TwoNTree","page":"PlotlyJS","title":"Visualizing a TwoNTree","text":"","category":"section"},{"location":"ext/h2plotlyjstrees/","page":"PlotlyJS","title":"PlotlyJS","text":"For TwoNTrees we have the helper-function tracecube, which can, for example, used like this","category":"page"},{"location":"ext/h2plotlyjstrees/","page":"PlotlyJS","title":"PlotlyJS","text":"using CompScienceMeshes\nusing H2Trees\nusing PlotlyJS\n\nm = meshsphere(1.0, 0.1)\ntree = TwoNTree(vertices(m), 0.1)\n\ntraces = [wireframe(skeleton(m, 1))]\n\nfor node in H2Trees.LevelIterator(tree, 4)\n    push!(traces, H2Trees.tracecube(tree, node; mode=\"lines\", line_color=:pink))\nend\n\np = PlotlyJS.plot(\n    traces,\n    Layout(;\n        scene=attr(;\n            xaxis=attr(; visible=false),\n            yaxis=attr(; visible=false),\n            zaxis=attr(; visible=false),\n        ),\n        showlegend=false,\n    ),\n)\n\nsavefig(p, \"sphere_tracecube.html\"); # hide\nnothing #hide","category":"page"},{"location":"ext/h2plotlyjstrees/","page":"PlotlyJS","title":"PlotlyJS","text":"<object data=\"../sphere_tracecube.html\" type=\"text/html\"  style=\"width:100%; height:50vh;\"> </object>","category":"page"},{"location":"ext/h2plotlyjstrees/#Visualizing-a-BoundingBallTree","page":"PlotlyJS","title":"Visualizing a BoundingBallTree","text":"","category":"section"},{"location":"ext/h2plotlyjstrees/","page":"PlotlyJS","title":"PlotlyJS","text":"For BoundingBallTrees we have the helper-function traceball, which can, for example, used like this","category":"page"},{"location":"ext/h2plotlyjstrees/","page":"PlotlyJS","title":"PlotlyJS","text":"using CompScienceMeshes\nusing H2Trees\nusing PlotlyJS\nusing ParallelKMeans\n\nm = meshsphere(1.0, 0.1)\ntree = KMeansTree(vertices(m), 4; minvalues=60)\n\ntraces = [wireframe(skeleton(m, 1))]\n\nfor node in H2Trees.LevelIterator(tree, 4)\n    push!(\n        traces,\n        H2Trees.traceball(tree, node; colorscale=[[0, :pink], [1, :pink]], \n        opacity=0.6, showscale=false),\n    )\nend\n\np = PlotlyJS.plot(\n    traces,\n    Layout(;\n        scene=attr(;\n            xaxis=attr(; visible=false),\n            yaxis=attr(; visible=false),\n            zaxis=attr(; visible=false),\n        ),\n    ),\n)\n\nsavefig(p, \"sphere_traceball.html\"); # hide\nnothing #hide","category":"page"},{"location":"ext/h2plotlyjstrees/","page":"PlotlyJS","title":"PlotlyJS","text":"<object data=\"../sphere_traceball.html\" type=\"text/html\"  style=\"width:100%; height:50vh;\"> </object>","category":"page"},{"location":"plans/aggregatetranslateplan/#Aggregate-Translate-Plan","page":"Aggregate Translate Plan","title":"Aggregate Translate Plan","text":"","category":"section"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"In order to contribute to this package directly create a pull request against the main branch. Before doing so please:  ","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Follow the style of the surrounding code.\nSupplement the documentation.\nWrite tests and check that no errors occur.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#Style","page":"Contributing","title":"Style","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"For a consistent style the JuliaFormatter.jl package is used which enforces the style defined in the .JuliaFormatter.toml file. To follow this style simply run","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using JuliaFormatter\nformat(pkgdir(H2Trees; overwrite=true))","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nThat all files follow the JuliaFormatter style is tested during the unit tests. Hence, do not forget to execute the two lines above. Otherwise, the tests are likely to not pass.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#Documentation","page":"Contributing","title":"Documentation","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Add documentation for any changes or new features following the style of the existing documentation. For more information you can have a look at the Documenter.jl documentation.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#Tests","page":"Contributing","title":"Tests","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Write tests for your code changes and verify that no errors occur, e.g., by running","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using Pkg\nPkg.test(\"H2Trees\")","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"For more detailed information on which parts are tested the coverage can be evaluated on your local machine, e.g., by","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using Pkg\nPkg.test(\"H2Trees\"; coverage=true, julia_args=`--threads 6`)\n\n# determine coverage\nusing Coverage\nsrc_folder = pkgdir(H2Trees) * \"/src\"\ncoverage   = process_folder(src_folder)\nLCOV.writefile(\"path-to-folder-you-like\" * \"H2Trees.lcov.info\", coverage)\n\nclean_folder(src_folder) # delete .cov files\n\n# extract information about coverage\ncovered_lines, total_lines = get_summary(coverage)\n@info \"Current coverage:\\n$covered_lines of $total_lines lines ($(round(Int, covered_lines / total_lines * 100)) %)\"","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"In Visual Studio Code the Coverage Gutters plugin can be used to visualize the tested lines of the code by inserting the path of the H2Trees.lcov.info file in the settings.","category":"page"},{"location":"twontree/#TwoNTree","page":"TwoNTree","title":"TwoNTree","text":"","category":"section"},{"location":"twontree/","page":"TwoNTree","title":"TwoNTree","text":"The TwoNTree is a 2ⁿ-tree for organizing points in ℝⁿ. In the case of three-dimensional points, this results in an octree. The TwoNTree can be constructed from a set of points and a minimum halfsize. Additionally, the minvalues parameter can be set to control the subdivision of the tree. A box is only further subdivided if it contains at least minvalues points.","category":"page"},{"location":"twontree/","page":"TwoNTree","title":"TwoNTree","text":"In the Galerkin case, the tree can be constructed as follows","category":"page"},{"location":"twontree/","page":"TwoNTree","title":"TwoNTree","text":"using  CompScienceMeshes # hide\nusing H2Trees # hide\n\nm = meshsphere(1.0, 0.1)\ntree = TwoNTree(vertices(m), 0.1; minvalues=60)","category":"page"},{"location":"twontree/","page":"TwoNTree","title":"TwoNTree","text":"Alternatively, the tree can be constructed with a minimum halfsize of 0:","category":"page"},{"location":"twontree/","page":"TwoNTree","title":"TwoNTree","text":"using  CompScienceMeshes # hide\nusing H2Trees # hide\n\nm = meshsphere(1.0, 0.1)\ntree = TwoNTree(vertices(m), 0.0; minvalues=60)","category":"page"},{"location":"twontree/","page":"TwoNTree","title":"TwoNTree","text":"In the Petrov-Galerkin case, the tree can be constructed by providing two sets of points","category":"page"},{"location":"twontree/","page":"TwoNTree","title":"TwoNTree","text":"using CompScienceMeshes\nusing H2Trees\n\nmx = meshsphere(1.0, 0.1)\nmy = meshsphere(2.0, 0.1)\n\ntree = TwoNTree(vertices(mx), vertices(my), 0.1)","category":"page"},{"location":"twontree/","page":"TwoNTree","title":"TwoNTree","text":"This creates a BlockTree with two TwoNTrees.","category":"page"},{"location":"twontree/","page":"TwoNTree","title":"TwoNTree","text":"note: Note\nThe trees are configured such that both trees have the same halfsize at the same level. This means that not every tree starts at level 1.","category":"page"},{"location":"simplehybridtree/#Simple-Hybrid-Tree","page":"Simple Hybrid Tree","title":"Simple Hybrid Tree","text":"","category":"section"},{"location":"simplehybridtree/","page":"Simple Hybrid Tree","title":"Simple Hybrid Tree","text":"A SimpleHybridTree is a tree that is split into two parts: an upper tree and a lower tree. The upper tree spans the levels from minlevel to hybridlevel, while the lower tree spans the levels from hybridlevel+1 to maxlevel. This allows the 𝓗² Method to treat both parts of the tree differently.","category":"page"},{"location":"simplehybridtree/","page":"Simple Hybrid Tree","title":"Simple Hybrid Tree","text":"A SimpleHybridTree can be constructed from a TwoNTree by specifying the hybridhalfsize parameter. The hybridhalfsize determines the level at which the tree is split.","category":"page"},{"location":"simplehybridtree/","page":"Simple Hybrid Tree","title":"Simple Hybrid Tree","text":"In the Galerkin case, a hybrid TwoNTree can be constructed as follows:","category":"page"},{"location":"simplehybridtree/","page":"Simple Hybrid Tree","title":"Simple Hybrid Tree","text":"using  CompScienceMeshes # hide\nusing H2Trees # hide\n\nm = meshsphere(1.0, 0.1)\ntree = SimpleHybridTree(TwoNTree(vertices(m), 0.1); hybridhalfsize=0.2)","category":"page"},{"location":"simplehybridtree/","page":"Simple Hybrid Tree","title":"Simple Hybrid Tree","text":"Translating plans can be split into two with the splitplan function.","category":"page"},{"location":"ext/h2beasttrees/#BEAST","page":"BEAST","title":"BEAST","text":"","category":"section"},{"location":"ext/h2beasttrees/","page":"BEAST","title":"BEAST","text":"The basis functions defined in BEAST.jl can be sorted into trees.","category":"page"},{"location":"ext/h2beasttrees/#TwoNTree","page":"BEAST","title":"TwoNTree","text":"","category":"section"},{"location":"ext/h2beasttrees/","page":"BEAST","title":"BEAST","text":"For TwoNTrees this can, for example, be done like this for the Galerkin case","category":"page"},{"location":"ext/h2beasttrees/","page":"BEAST","title":"BEAST","text":"using BEAST, CompScienceMeshes\nusing H2Trees\n\nm = meshsphere(1.0, 0.1)\nX = raviartthomas(m)\ntree = TwoNTree(X, 0.1)","category":"page"},{"location":"ext/h2beasttrees/","page":"BEAST","title":"BEAST","text":"and for the Petrov-Galerkin case","category":"page"},{"location":"ext/h2beasttrees/","page":"BEAST","title":"BEAST","text":"using BEAST, CompScienceMeshes\nusing H2Trees\nusing PlotlyJS\n\nm = meshsphere(1.0, 0.1)\nX = raviartthomas(m)\nY = buffachristiansen(m)\ntree = TwoNTree(X, Y, 0.1)","category":"page"},{"location":"ext/h2beasttrees/#QuadPointsTree","page":"BEAST","title":"QuadPointsTree","text":"","category":"section"},{"location":"ext/h2beasttrees/","page":"BEAST","title":"BEAST","text":"Similarly QuadPointsTrees can be constructed for BEAST.jl spaces for the Galerkin case","category":"page"},{"location":"ext/h2beasttrees/","page":"BEAST","title":"BEAST","text":"using BEAST, CompScienceMeshes\nusing H2Trees\n\nm = meshsphere(1.0, 0.1)\nX = raviartthomas(m)\ntree = QuadPointsTree(X, 0.1)","category":"page"},{"location":"ext/h2beasttrees/","page":"BEAST","title":"BEAST","text":"and for the Petrov-Galerkin case","category":"page"},{"location":"ext/h2beasttrees/","page":"BEAST","title":"BEAST","text":"using BEAST, CompScienceMeshes\nusing H2Trees\nusing PlotlyJS\n\nm = meshsphere(1.0, 0.1)\nX = raviartthomas(m)\nY = buffachristiansen(m)\ntree = QuadPointsTree(X, Y, 0.1)","category":"page"},{"location":"plans/disaggregatetranslateplan/#Disaggregate-Translate-Plan","page":"Disaggregate Translate Plan","title":"Disaggregate Translate Plan","text":"","category":"section"},{"location":"quadpointtree/#Quad-Points-Tree","page":"Quad Points Tree","title":"Quad Points Tree","text":"","category":"section"},{"location":"iterators/#Iterators","page":"Iterators","title":"Iterators","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"Iterators allow to traverse the tree.","category":"page"},{"location":"iterators/#Depth-First","page":"Iterators","title":"Depth First","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The DepthFirstIterator traverses the tree in a depth first manner. If no node is specified the tree is traversed from the root node.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using CompScienceMeshes # hide\nusing H2Trees # hide\n\nm = meshsphere(1.0, 0.1)\ntree = TwoNTree(vertices(m), 0.1)\nprintln(collect(H2Trees.DepthFirstIterator(tree)))","category":"page"},{"location":"iterators/#Parents-Upward","page":"Iterators","title":"Parents Upward","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The ParentUpwardsIterator is an iterator that iterates over all parent nodes of a given node in a tree until the root is reached. The last node is the node 0.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using CompScienceMeshes # hide\nusing H2Trees # hide\n\nm = meshsphere(1.0, 0.1)\ntree = TwoNTree(vertices(m), 0.1)\nprintln(collect(H2Trees.ParentUpwardsIterator(tree, 373)))","category":"page"},{"location":"iterators/#Children","page":"Iterators","title":"Children","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The ChildIterator is an iterator over the children of a node in a tree.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using CompScienceMeshes # hide\nusing H2Trees # hide\n\nm = meshsphere(1.0, 0.1)\ntree = TwoNTree(vertices(m), 0.1)\nprintln(collect(H2Trees.children(tree, H2Trees.root(tree))))","category":"page"},{"location":"iterators/#Leaves","page":"Iterators","title":"Leaves","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"leaves returns an iterator over the leaf nodes in the tree, starting from the specified node. If no node is specified the tree is traversed from the root node.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using CompScienceMeshes # hide\nusing H2Trees # hide\n\nm = meshsphere(1.0, 0.1)\ntree = TwoNTree(vertices(m), 0.1)\nprintln(collect(H2Trees.leaves(tree)))","category":"page"},{"location":"iterators/#Level-Iterator","page":"Iterators","title":"Level Iterator","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"LevelIterator return an iterator over the nodes at the specified level in the tree.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using CompScienceMeshes # hide\nusing H2Trees # hide\n\nm = meshsphere(1.0, 0.1)\ntree = TwoNTree(vertices(m), 0.1)\nprintln(collect(H2Trees.LevelIterator(tree,2)))","category":"page"},{"location":"iterators/#Same-Level-Nodes","page":"Iterators","title":"Same Level Nodes","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"[SameLevelIterator] returns an iterator over the nodes at the same level as node in the tree.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using CompScienceMeshes # hide\nusing H2Trees # hide\n\nm = meshsphere(1.0, 0.1)\ntree = TwoNTree(vertices(m), 0.1)\nprintln(collect(H2Trees.SameLevelIterator(tree,3)))","category":"page"},{"location":"iterators/#Near-and-Far-Nodes","page":"Iterators","title":"Near- and Far Nodes","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The NearNodeIterator returns, in the Galerkin case, an iterator over the nodes in the tree that are at the same level as the specified node and are near to node. Two nodes are near if the function isnear(tree, nodea, nodeb) evaluates to true.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using CompScienceMeshes # hide\nusing H2Trees # hide\n\nm = meshsphere(1.0, 0.1)\ntree = TwoNTree(vertices(m), 0.1)\nprintln(\"node 4 is at level \", H2Trees.level(tree, 4))\nprintln(\"nodes near to node 4: \", collect(H2Trees.NearNodeIterator(tree, 4)))","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"In the Petrov-Galerkin case the NearNodeIterator returns an iterator over the nodes in the testtree that are at the same level as the specified node in the trialtree and are near to node. Two nodes are near if the function isnear(testtree, trialtree, testnode, trialnode) evaluates to true.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using CompScienceMeshes # hide\nusing H2Trees # hide\n\nmx = meshsphere(1.0, 0.1)\nmy = meshsphere(2.0, 0.1)\n\ntesttree = TwoNTree(vertices(mx), 0.1)\ntrialtree = TwoNTree(vertices(my), 0.1)\nprintln(\"trial node 4 is at level \", H2Trees.level(trialtree, 4))\nprintln(\"nodes near to trial node 4: \", collect(H2Trees.NearNodeIterator(testtree, trialtree, 4)))","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The FarNodeIterator is defined accordingly.","category":"page"},{"location":"iterators/#Well-Separated-Nodes","page":"Iterators","title":"Well Separated Nodes","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The WellSeparatedIterator is used to identify which translations should occur and which should not. This determination is based on the concept of well-separated nodes.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"note: Note\nTwo nodes are considered well-separated if their parents are near each other and the nodes themselves are far apart. This assumes that child clusters are completely inside their parent clusters.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The WellSeparatedIterator can be configured using either an isnear or an iswellseparated function.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The following example demonstrates the usage of the WellSeparatedIterator in the Galerkin-case","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using CompScienceMeshes # hide\nusing H2Trees # hide\n\nm = meshsphere(1.0, 0.1)\ntree = KMeansTree(vertices(m), 4; minvalues=60)\n\n# Using the WellSeparatedIterator with the default isnear() function\nprintln(\"First iterator\\t\", collect(H2Trees.WellSeparatedIterator(tree, 3)))\n\n# Creating a functor without specifying a tree first\nfunctor = H2Trees.WellSeparatedIterator()\niterator = functor(tree)\nprintln(\"Second iterator\\t\", collect(iterator(tree, 3)))\n\n# Specifying a custom iswellseparated criterion\nfunctor = H2Trees.WellSeparatedIterator(; iswellseparated=(tree) -> (tree, nodea, nodeb) -> iseven(nodea))\niterator = functor(tree)\nprintln(\"Third iterator\\t\", collect(iterator(tree, 3)))\n\n# Specifying a custom isnear criterion\nfunctor = H2Trees.WellSeparatedIterator(; isnear=(tree) -> (tree, nodea, nodeb) -> iseven(nodea))\niterator = functor(tree)\nprintln(\"Fourth iterator\\t\", collect(iterator(tree, 3)))","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"When defining the isnear or iswellseparated criterion, it is necessary to provide a function that takes a tree as input and returns another function. This returned function is then used to evaluate the criterion.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"At first glance, this may seem like an unnecessary layer of indirection. However, it actually provides a significant advantage: it enables precomputations that can be performed only once, when the criterion function is first created, rather than every time the iterator is called.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"By allowing the initial function to perform any necessary precomputations and store the results, the returned function can then simply use these precomputed values to evaluate the criterion. This can significantly improve performance, especially when working with large trees or complex criteria.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"For the Petrov-Galerkin case, we assume that translations occur from the trialtree to the testtree. This scenario can be demonstrated with the following example","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using CompScienceMeshes # hide\nusing H2Trees # hide\n\nmx = meshsphere(1.0, 0.1)\nmy = meshsphere(2.0, 0.1)\n\ntree = TwoNTree(vertices(mx), vertices(my), 0.1)\n\n# Using the WellSeparatedIterator with the default isnear() function\nprintln(\"First iterator\\t\", collect(H2Trees.WellSeparatedIterator(tree, 4)))\n\n# Creating a functor without specifying a tree first\nfunctor = H2Trees.WellSeparatedIterator()\niterator = functor(tree)\nprintln(\"Second iterator\\t\", collect(iterator(H2Trees.testtree(tree), H2Trees.trialtree(tree), 4)))\n\n# Specifying a custom iswellseparated criterion\nfunctor = H2Trees.WellSeparatedIterator(;\n    iswellseparated=(tree) -> (testtree, trialtree, testnode, trialnode) -> iseven(testnode)\n)\niterator = functor(tree)\nprintln(\"Third iterator\\t\", collect(iterator(H2Trees.testtree(tree), H2Trees.trialtree(tree), 4)))\n\n# Specifying a custom isnear criterion\nfunctor = H2Trees.WellSeparatedIterator(;\n    isnear=(tree) -> (testtree, trialtree, testnode, trialnode) -> iseven(testnode)\n)\niterator = functor(tree)\nprintln(\"Fourth iterator\\t\", collect(iterator(H2Trees.testtree(tree), H2Trees.trialtree(tree), 4)))","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"In general, it is more efficient to use functors instead of functions in this context.","category":"page"},{"location":"iterators/#Translating-Nodes","page":"Iterators","title":"Translating Nodes","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The TranslatingNodesIterator is a wrapper for the WellSeparatedIterator.","category":"page"},{"location":"iterators/#Filtering-Nodes","page":"Iterators","title":"Filtering Nodes","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"NodeFilterIterator returns an iterator over nodes at the same level as trialnode in trialtree, for which the function filter(testtree, trialtree, testnode, trialnode) return true. In the case of a tree with the trait isBlockTree, it is assumed that trialnode is belonging to the trialtree. For the Galerkin case, we have","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using CompScienceMeshes # hide\nusing H2Trees # hide\n\nm = meshsphere(1.0, 0.1)\ntree = TwoNTree(vertices(m), 0.1)\nprintln(collect(H2Trees.NodeFilterIterator(tree, 3, (tree, nodea, nodeb)-> iseven(nodea))))","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"and for the Petrov-Galerkin case","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using CompScienceMeshes # hide\nusing H2Trees # hide\n\nmx = meshsphere(1.0, 0.1)\nmy = meshsphere(2.0, 0.1)\n\ntree = TwoNTree(vertices(mx), vertices(my), 0.1)\ntesttree = H2Trees.testtree(tree)\ntrialtree = H2Trees.trialtree(tree)\nprintln(collect(H2Trees.NodeFilterIterator(tree, 3, (testree, trialtree, testnode, trialnode)-> iseven(testnode))))","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"and","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using CompScienceMeshes # hide\nusing H2Trees # hide\n\nmx = meshsphere(1.0, 0.1)\nmy = meshsphere(2.0, 0.1)\n\ntree = TwoNTree(vertices(mx), vertices(my), 0.1)\ntesttree = H2Trees.testtree(tree)\ntrialtree = H2Trees.trialtree(tree)\nprintln(collect(H2Trees.NodeFilterIterator(testtree, trialtree, 3, (testree, trialtree, testnode, trialnode)-> iseven(testnode))))","category":"page"},{"location":"translations/#Translations","page":"Translations","title":"Translations","text":"","category":"section"},{"location":"translations/","page":"Translations","title":"Translations","text":"The following implementations of the AbstractTranslationTrait are available, enabling the specification of translations in a tree and reducing computational and storage requirements.","category":"page"},{"location":"translations/","page":"Translations","title":"Translations","text":"Translation Trait Description\nAllTranslations Store and compute all translations individually.\nDirectionInvariance Treat translations with the same length and direction as identical.\nDirectionInvariancePerLevel Treat translations on the same level with the same length and direction as identical.","category":"page"},{"location":"translations/","page":"Translations","title":"Translations","text":"The translations can be computed with the translations function. The result is a tuple containing two vectors:","category":"page"},{"location":"translations/","page":"Translations","title":"Translations","text":"The first vector contains NamedTuples with fields receivingnode, translatingnode, and translationID.   The translationID is the id of the translation in the translation directions.\nThe second vector contains the translation directions.","category":"page"},{"location":"translations/","page":"Translations","title":"Translations","text":"This can for example look like","category":"page"},{"location":"translations/","page":"Translations","title":"Translations","text":"using CompScienceMeshes # hide\nusing H2Trees # hide\n\nm = meshsphere(1.0, 0.1)\ntree = TwoNTree(vertices(m), 0.1)\n\n# define iterator, which specifies which translations occur (we use the default isnear() function) \ntfiterator = H2Trees.TranslatingNodesIterator(; isnear=H2Trees.isnear())\n# we are going to aggregate all nodes, even though that might not be needed and we use the AggregateMode\nplans = H2Trees.galerkinplans(tree, H2Trees.AggregateAllNodesFunctor(), tfiterator, H2Trees.AggregateMode())\n\n# the translations can be found in the testdisaggregationplan in AggregateMode\nfor translationtrait in [H2Trees.AllTranslations(), H2Trees.DirectionInvariance(),  H2Trees.DirectionInvariancePerLevel()]\n    translationinfo, translations = H2Trees.translations(tree, plans.testdisaggregationplan, translationtrait)\n    println(\"For translationtrait $(typeof(translationtrait)) we have $(length(translations)) unique translations.\")\nend","category":"page"},{"location":"translations/","page":"Translations","title":"Translations","text":"and in the Petrov-Galerkin case","category":"page"},{"location":"translations/","page":"Translations","title":"Translations","text":"using CompScienceMeshes # hide\nusing H2Trees # hide\n\nmx = meshsphere(1.0, 0.1)\nmy = meshsphere(2.0, 0.1)\n\ntree = TwoNTree(vertices(mx), vertices(my), 0.1)\ntesttree = H2Trees.testtree(tree)\ntrialtree = H2Trees.trialtree(tree)\n\n# define iterator, which specifies which translations occur (we use the default isnear() function) \ntfiterator = H2Trees.TranslatingNodesIterator(; isnear=H2Trees.isnear())\n\n# we are going to aggregate all nodes, even though that might not be needed and we use the AggregateMode\nplans = H2Trees.petrovplans(tree, H2Trees.AggregateAllNodesFunctor(), tfiterator, H2Trees.AggregateMode())\n\n# the translations can be found in the testdisaggregationplan in AggregateMode\nfor translationtrait in [H2Trees.AllTranslations(), H2Trees.DirectionInvariance(),  H2Trees.DirectionInvariancePerLevel()]\n    translationinfo, translations = H2Trees.translations(tree, plans.testdisaggregationplan, translationtrait)\n    println(\"For translationtrait $(typeof(translationtrait)) we have $(length(translations)) unique translations.\")\nend","category":"page"},{"location":"#𝓗-Trees","page":"Home","title":"𝓗² Trees","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The H2Trees package provides a Julia implementation of tree data structures and algorithms for efficient computation in the context of 𝓗² methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"H2Trees builds upon ideas from ClusterTrees and provides a range of tree data structures, including:","category":"page"},{"location":"","page":"Home","title":"Home","text":"TwoNTree: A 2ⁿ-tree data structure for organizing points in ℝⁿ.\nSimpleHybridTree: A tree data structure that splits a tree\nBoundingBallTree: A tree data structure using bounding balls.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The H2Trees package provides a range of features, including","category":"page"},{"location":"","page":"Home","title":"Home","text":"Aggregation and disaggregation: Plans for implementing aggregation and disaggregation algorithms for efficient computation.\nComputation of translations: Algorithms for computing translations between different tree levels.\nPlotting: An interface to PlotlyJS.jl for visualizing tree data structures.\nInterface to BEAST: An interface to the BEAST package for clustering of basis functions.","category":"page"},{"location":"#Goals","page":"Home","title":"Goals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The primary goal of the H2Trees package is to provide an efficient and flexible framework for computing 𝓗² methods, and related quantities. The package aims to provide a range of features and tools for working with tree data structures, including aggregation, disaggregation, and plotting.","category":"page"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The H2Trees package is related to the following packages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ClusterTrees\nBEAST\nH2Factory\nMLFMA\niFMM\nHybridFMM","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This documentation provides an overview of the H2Trees package, including its features, goals, and related packages. For more information, please see the individual documentation pages for each module and function.","category":"page"},{"location":"plans/disaggregateplan/#Disaggregate-Plan","page":"Disaggregate Plan","title":"Disaggregate Plan","text":"","category":"section"}]
}
